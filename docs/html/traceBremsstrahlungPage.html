<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Raytracer: Trace through mesh and absorb energy via bremsstrahlung</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Raytracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Trace through mesh and absorb energy via bremsstrahlung </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#brems_sec">Bremsstrahlung absorption</a><ul><li class="level2"><a href="#brems_subsec1">Code explanation</a></li>
<li class="level2"><a href="#brems_subsec2">Running the example and plotting</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"> A simple example demonstrating tracing and bremsstrahlung model usage.</p>
<h1><a class="anchor" id="brems_sec"></a>
Bremsstrahlung absorption</h1>
<p>First make sure that you have raytracer properly setup and that you have a vtk mesh file which you wish to be traced through. You can use the file bundled with this example in data folder. You can find the whole example in raytracer/examples/sampleGradient. </p>
<h2><a class="anchor" id="brems_subsec1"></a>
Code explanation</h2>
<p>First lets define temperature, density and ionization functions that will be used to find a correct path and absorbed energy for each ray: <div class="fragment"><div class="line"><span class="keywordtype">double</span> densityFunction(<span class="keyword">const</span> mfem::Vector &amp;x) {</div><div class="line">    <span class="keywordflow">return</span> 1e26 * x(0) + 6.44713e+20;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> temperatureFunction(<span class="keyword">const</span> mfem::Vector &amp;) {</div><div class="line">    <span class="keywordflow">return</span> 2000;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> ionizationFunction(<span class="keyword">const</span> mfem::Vector &amp;) {</div><div class="line">    <span class="keywordflow">return</span> 22;</div><div class="line">}</div></div><!-- fragment --> The executable code is defined in main, where the raytracer namespace is used: <div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span> *[]) {</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceraytracer.html">raytracer</a>;</div></div><!-- fragment --></p>
<p>Make sure to load the vtk mesh and wrap it into <a class="el" href="classraytracer_1_1Mesh.html" title="Class representing a mesh (2D for now). ">raytracer::Mesh</a>. Besides that we will need a mfem::FiniteElementSpace: <div class="fragment"><div class="line">    <span class="keyword">auto</span> mfemMesh = std::make_unique&lt;mfem::Mesh&gt;(<span class="stringliteral">&quot;data/mesh.vtk&quot;</span>, 1, 0);</div><div class="line">    Mesh mesh(mfemMesh.get());</div><div class="line">    mfem::L2_FECollection l2FiniteElementCollection(0, 2);</div><div class="line">    mfem::FiniteElementSpace l2FiniteElementSpace(mfemMesh.get(), &amp;l2FiniteElementCollection);</div></div><!-- fragment --></p>
<p>Now in real simulation it is expected that a mfem::GridFunction holding the absorbed energy is already defined. Here we have to define it. In any case it must be wrapped by <a class="el" href="classraytracer_1_1MfemMeshFunction.html" title="Discrete function what has constant values at Mesh elements. ">raytracer::MfemMeshFunction</a>. Note that <a class="el" href="classraytracer_1_1MfemMeshFunction.html" title="Discrete function what has constant values at Mesh elements. ">raytracer::MfemMeshFunction</a> holds a reference to the mfem::GridFunction and will crash if the referenced GridFunction is deleted: <div class="fragment"><div class="line">    mfem::GridFunction absorbedEnergyGridFunction(&amp;l2FiniteElementSpace);</div><div class="line">    absorbedEnergyGridFunction = 0;</div><div class="line">    MfemMeshFunction absorbedEnergyMeshFunction(absorbedEnergyGridFunction, l2FiniteElementSpace);</div></div><!-- fragment --></p>
<p>In a similar fashion temperature, density and ionization grid functions are wrapped. In this example these have the analytical forms defined at the beginning. This might seem as it could be simplified, but remember that this is expected to be already defined: <div class="fragment"><div class="line">    mfem::GridFunction densityGridFunction(&amp;l2FiniteElementSpace);</div><div class="line">    mfem::FunctionCoefficient densityFunctionCoefficient(densityFunction);</div><div class="line">    densityGridFunction.ProjectCoefficient(densityFunctionCoefficient);</div><div class="line">    MfemMeshFunction densityMeshFunction(densityGridFunction, l2FiniteElementSpace);</div><div class="line"></div><div class="line">    mfem::GridFunction temperatureGridFunction(&amp;l2FiniteElementSpace);</div><div class="line">    mfem::FunctionCoefficient temperatureFunctionCoefficient(temperatureFunction);</div><div class="line">    temperatureGridFunction.ProjectCoefficient(temperatureFunctionCoefficient);</div><div class="line">    MfemMeshFunction temperatureMeshFunction(temperatureGridFunction, l2FiniteElementSpace);</div><div class="line"></div><div class="line">    mfem::GridFunction ionizationGridFunction(&amp;l2FiniteElementSpace);</div><div class="line">    mfem::FunctionCoefficient ionizationFunctionCoefficient(ionizationFunction);</div><div class="line">    ionizationGridFunction.ProjectCoefficient(ionizationFunctionCoefficient);</div><div class="line">    MfemMeshFunction ionizationMeshFunction(ionizationGridFunction, l2FiniteElementSpace);</div></div><!-- fragment --></p>
<p>Now we will define the actual physical situation and models used. </p><dl class="section note"><dt>Note</dt><dd>The previous code is just a boilerplate, the actual usage of raytracer is best shown at following lines.</dd></dl>
<p>A <a class="el" href="classraytracer_1_1Gradient.html" title="Abstract interface to provide a GradientCalculator. ">raytracer::Gradient</a> calculation model is needed. Here we use the <a class="el" href="classraytracer_1_1LeastSquare.html" title="Gradient model computes the gradient by fitting a plane to neighbour cells by means of lest squares...">raytracer::LeastSquare</a> gradient which is initialized using mesh and density <a class="el" href="classraytracer_1_1MeshFunction.html" title="Abstract interface. ">raytracer::MeshFunction</a>. <div class="fragment"><div class="line">    LeastSquare leastSquareGradient(mesh, densityMeshFunction);</div></div><!-- fragment --></p>
<p>A <a class="el" href="classraytracer_1_1CollisionalFrequency.html" title="Abstract interface. ">raytracer::CollisionalFrequency</a> model is also necessary. Here a <a class="el" href="classraytracer_1_1SpitzerFrequency.html" title="Class representing a Spitzer-Harm frequency calculator. ">raytracer::SpitzerFrequency</a> is used: <div class="fragment"><div class="line">    SpitzerFrequency spitzerFrequency;</div></div><!-- fragment --></p>
<p>To decide which direction should be take after encountering a mesh face a proper direction finder must be specified. Such a functor is <a class="el" href="structraytracer_1_1SnellsLaw.html" title="Functor that finds new direction base on the Snells&#39;s law. ">raytracer::SnellsLaw</a> which as the name suggests uses Snell's law to determine the direction. Initialize it using all the necessary models: <div class="fragment"><div class="line">    SnellsLaw snellsLaw(</div><div class="line">            densityMeshFunction,</div><div class="line">            temperatureMeshFunction,</div><div class="line">            ionizationMeshFunction,</div><div class="line">            leastSquareGradient,</div><div class="line">            spitzerFrequency</div><div class="line">    );</div></div><!-- fragment --></p>
<p>Now we will initialize an incoming <a class="el" href="classraytracer_1_1Laser.html" title="Class representing a real physical laser. ">raytracer::Laser</a>. The laser begins on a line between points (-0.51e-5, -0.3e-5) and (-0.51e-5, -0.5e-5). Its direction is in every point on the line (1, 0.7). It has a gaussian profile of energy with FWHM 0.3e-5 and energy total of 1: <div class="fragment"><div class="line">    Laser laser(</div><div class="line">            Length{1315e-7},</div><div class="line">            [](<span class="keyword">const</span> Point) { <span class="keywordflow">return</span> Vector(1, 0.7); },</div><div class="line">            Gaussian(0.3e-5, 1, 0),</div><div class="line">            Point(-0.51e-5, -0.3e-5),</div><div class="line">            Point(-0.51e-5, -0.5e-5)</div><div class="line">    );</div></div><!-- fragment --></p>
<p>All that is left for the tracing part of the simulation is to generate the laser rays for the given <a class="el" href="classraytracer_1_1Laser.html" title="Class representing a real physical laser. ">raytracer::Laser</a> and trace these through the <a class="el" href="classraytracer_1_1Mesh.html" title="Class representing a mesh (2D for now). ">raytracer::Mesh</a>. We do this using generateRays and generateIntersections methods: <div class="fragment"><div class="line">    laser.generateRays(100);</div><div class="line">    laser.generateIntersections(mesh, snellsLaw, <a class="code" href="group__intersectionFinders.html#ga88bd3438a657bdf333afdd59cd675798">intersectStraight</a>, DontStop());</div></div><!-- fragment --> <a class="el" href="group__intersectionFinders.html#ga88bd3438a657bdf333afdd59cd675798" title="Function to be used in Laser::generateIntersections() as findIntersection. ">raytracer::intersectStraight</a> means that the cells are intersected straight, not that the whole ray is straight. <a class="el" href="structraytracer_1_1DontStop.html" title="Functor for ray propagation that returns false in any case. ">raytracer::DontStop</a> just says the laser should be traced as long as it is possible.</p>
<p>Now with laser that intersects the mesh its time to exchange energy between the laser and the hypothetical medium. To do so initialize an <a class="el" href="classraytracer_1_1AbsorptionController.html" title="Class aggregating all instances of AbsorptionModel used to update absorbedEnergy meshFunction. ">raytracer::AbsorptionController</a>. <div class="fragment"><div class="line">    AbsorptionController absorber;</div></div><!-- fragment --></p>
<p>Specify the absorption models that are going to be used and register these to <a class="el" href="classraytracer_1_1AbsorptionController.html" title="Class aggregating all instances of AbsorptionModel used to update absorbedEnergy meshFunction. ">raytracer::AbsorptionController</a>. Here just one model is used, the <a class="el" href="structraytracer_1_1Bremsstrahlung.html" title="Absorption model of energy exchange due to bremsstrahlung. ">raytracer::Bremsstrahlung</a>: <div class="fragment"><div class="line">    Bremsstrahlung bremsstrahlungModel(</div><div class="line">            densityMeshFunction,</div><div class="line">            temperatureMeshFunction,</div><div class="line">            ionizationMeshFunction,</div><div class="line">            spitzerFrequency</div><div class="line">    );</div><div class="line">    absorber.addModel(&amp;bremsstrahlungModel);</div></div><!-- fragment --></p>
<p>Update the absorbedEnergy <a class="el" href="classraytracer_1_1MeshFunction.html" title="Abstract interface. ">raytracer::MeshFunction</a> accordingly: <div class="fragment"><div class="line">    absorber.absorb(laser, absorbedEnergyMeshFunction);</div></div><!-- fragment --></p>
<p>And at last write the output to files: <div class="fragment"><div class="line">    laser.saveRaysToJson(<span class="stringliteral">&quot;data/rays.json&quot;</span>);</div><div class="line">    std::ofstream absorbedResult(<span class="stringliteral">&quot;data/absorbed_energy.txt&quot;</span>);</div><div class="line">    absorbedEnergyGridFunction.Save(absorbedResult);</div></div><!-- fragment --></p>
<h2><a class="anchor" id="brems_subsec2"></a>
Running the example and plotting</h2>
<p>To run the example compile it using cmake and your compiler of choice. Make sure to run it inside the examples/sampleGradient folder as the paths to external files are hardcoded. Executing the script will result in absorbed_energy.txt and rays.json being generated inside the data folder.</p>
<p>To plot these make sure that you have python <a href="https://github.com/SachCZ/rayvis">rayvis</a> installed. Then just run python3 plot_bremsstrahlung.py inside the same folder. This will generate two images inside the images folder. One depicting the how the rays were traced through the mesh and one showing the amount of absorbed energy due to bremsstrahlung.</p>
<div class="image">
<img src="absorbed_bremsstrahlung_energy.png" alt="absorbed_bremsstrahlung_energy.png"/>
</div>
 <div class="image">
<img src="bremsstrahlung_rays.png" alt="bremsstrahlung_rays.png"/>
</div>
 </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
